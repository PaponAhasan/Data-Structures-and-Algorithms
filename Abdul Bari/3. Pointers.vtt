WEBVTT

0
00:00.090 --> 00:02.570
In this video we will learn about pointers.

1
00:02.580 --> 00:07.440
So, first of all, I'll give you the definition of a pointer. What does it mean by pointer? and Why we require

2
00:07.440 --> 00:08.280
Why we require pointers?

3
00:08.280 --> 00:11.300
Then I'll show you how to declare and how to initialize,

4
00:11.520 --> 00:13.650
What does it mean by dereferencing?

5
00:13.650 --> 00:19.170
And we'll also learn about dynamic memory allocation. So, Let us start with the definition.

6
00:19.240 --> 00:27.840
See, the definition of a pointer. Pointer is an address variable that is meant for storing address of data,

7
00:28.830 --> 00:37.100
not the data itself; normal variables are data variables, but the pointers are address variables, and Pointers

8
00:37.100 --> 00:39.590
are used for indirectly accessing the data.

9
00:40.460 --> 00:43.700
So the question is, Why do you need to access data indirectly?

10
00:44.480 --> 00:47.500
So let us understand why actually we need pointers.

11
00:47.510 --> 00:49.880
Then we will see how to declare and use them.

12
00:49.880 --> 00:53.510
So first of all see this picture again I'm drawing it here.

13
00:53.630 --> 00:55.170
See this is the main memory.

14
00:55.310 --> 00:57.020
Main memory.

15
00:57.830 --> 00:58.510
Right.

16
00:58.520 --> 01:03.590
And this is the CPU which will execute our programs. So, how this main memory is utilized?

17
01:03.590 --> 01:06.010
Already this picture we're following it.

18
01:06.080 --> 01:08.320
This is divided into three parts here.

19
01:08.330 --> 01:10.250
Actually our program resides.

20
01:10.280 --> 01:11.790
So I'm writing main function.

21
01:11.930 --> 01:14.130
It will be having more of the functions.

22
01:14.180 --> 01:20.970
Now, this area, See this is a stack, so actually stack will be on the top, right, but I'm showing it here.

23
01:21.110 --> 01:23.930
Then the other part of the memories heap memory.

24
01:23.930 --> 01:30.420
So the main memory is divided into three sections and utilized this is code section.

25
01:30.510 --> 01:37.250
This is code section, and this is stack, and this is heap. So Code section, and, this will be stack and

26
01:37.250 --> 01:42.440
this will be heap, but I usually show here as the stack, so it's easy for understanding. Anyway,

27
01:42.470 --> 01:45.880
There are three portions of memory, code section, stack and heap.

28
01:45.950 --> 01:50.500
So the program will utilize the main memory by dividing into three sections.

29
01:50.540 --> 01:55.490
So this program can directly access these two areas.

30
01:55.550 --> 02:03.580
What are those? code section and stack; program will not automatically access heap, right. The policy for program is

31
02:03.590 --> 02:05.000
It will not directly access it.

32
02:05.390 --> 02:09.420
So heap memory is external to the program, outside the program.

33
02:10.190 --> 02:15.200
So program doesn't directly access, then how to access that? From that it needs a pointer.

34
02:15.440 --> 02:20.360
Yes, one of the reason of using pointer is accessing heap memory.

35
02:20.750 --> 02:26.270
So program should have a pointer within itself and with that point that it can access anything

36
02:26.270 --> 02:27.110
in the heap.

37
02:27.110 --> 02:32.590
So I may have an array or anything inside heap and the program can access it.

38
02:32.690 --> 02:39.260
So, for accessing this memory from the program we need a pointer. So, pointer is useful for accessing the

39
02:39.260 --> 02:42.270
resources that are outside the program.

40
02:42.290 --> 02:49.370
So this is one example, heap is one thing. Then, if the files are on the hard disk, now for accessing

41
02:49.430 --> 02:55.340
a file, program cannot access this hard disk files directly, because hard disk is external or files are

42
02:55.430 --> 03:00.650
external to a program, so far that, it needs a pointer for accessing and that pointer should be a file

43
03:00.680 --> 03:08.600
type and we can access that file. Then, a program may be accessing a keyboard, a program may be accessing

44
03:08.960 --> 03:15.950
a monitor, a program may be accessing internet or network connection, all these things are external to

45
03:15.950 --> 03:23.040
a program, so all these things can be accessed with the help of pointers. So, one major usage of pointer

46
03:23.090 --> 03:27.500
is accessing the resources which are outside the program.

47
03:27.660 --> 03:37.590
So, I will list it, see pointers are used for accessing heap memory, right, and for accessing resources

48
03:40.590 --> 03:48.420
and pointers are used for parameter passing also, this I will be explaining

49
03:48.520 --> 03:53.620
afterwards, how pointers are useful for passing parameters.

50
03:53.640 --> 03:59.730
So these are the major usages of pointer. Accessing heap, which is like a resource accessing, other resources

51
04:00.240 --> 04:01.610
or parameter passing.

52
04:02.610 --> 04:07.610
So, now next, Let us learn how to declare a pointer, how to initialize and how to use it.

53
04:07.620 --> 04:12.430
So by taking some small example, I will show you. This is our data variable.

54
04:13.070 --> 04:16.730
I'm declaring a and also initialize it, right.

55
04:17.100 --> 04:22.460
So this is a data variable, and normally we declare variables like this. 

56
04:22.460 --> 04:24.830
Then, second thing, pointer.

57
04:24.960 --> 04:28.580
This is the address variable, right.

58
04:28.580 --> 04:36.340
This is an address variable, so address variables are called as pointers in C C++ .

59
04:36.350 --> 04:38.330
Normally we declare the variables like this.

60
04:38.330 --> 04:40.520
Suppose this is inside a main function,

61
04:40.520 --> 04:41.950
I'm writing it as a function, okay,

62
04:42.060 --> 04:48.650
So this variable, it will occupy the memory inside the stack frame of our main function, inside the

63
04:48.650 --> 04:50.630
stack, like it is having value 10.

64
04:51.080 --> 04:53.840
So if I draw its bigger picture here,

65
04:53.840 --> 04:55.760
So, like, this is there. Suppose,

66
04:56.060 --> 04:59.810
This is taking 2 bytes, integer is taking 2 bytes, so it's as

67
04:59.810 --> 05:01.850
200 and 201.

68
05:01.880 --> 05:04.520
There are two bytes in which this value is stored.

69
05:04.580 --> 05:09.440
One is 200 and other is 201, right, so 2 bytes.

70
05:09.440 --> 05:11.330
See that is the reason to show only 2 bytes,

71
05:11.330 --> 05:19.070
I am saying integer is taking 2 bytes, so 2 addresses. Now, this is a pointer, this pointer I will initialize it,

72
05:19.220 --> 05:21.220
So, I will initialize it in the next line.

73
05:21.250 --> 05:23.750
p = &a ;

74
05:23.900 --> 05:26.520
So this will store the address of a.

75
05:26.630 --> 05:27.270
So what is this p?

76
05:27.270 --> 05:27.940
So what is this p?

77
05:28.050 --> 05:31.100
p will also occupy memory, pointer is also variable.

78
05:31.100 --> 05:32.670
This will also occupy memory.

79
05:32.780 --> 05:37.580
So this is created inside the stack frame of the same main function.

80
05:38.390 --> 05:43.450
If I show it diagrammatically, it looks like this. This pointer will also take 2 bytes.

81
05:43.490 --> 05:51.060
So let us say the address of this pointer is 210 and 211, just I am assuming a random number,

82
05:51.530 --> 05:55.480
Don't confuse that, the next should be 202. Whatever it may be,

83
05:55.490 --> 06:00.530
I am saying it is as 210 and 211. Now, when I say &a,

84
06:00.530 --> 06:04.880
This will have the address of this variable, So it is pointing to this one.

85
06:06.080 --> 06:12.880
So here, inside the memory if you see this is pointing to this one. So that pointer is pointing there, right.

86
06:13.450 --> 06:15.210
Now focus on the syntax.

87
06:15.220 --> 06:18.010
This is a variable, this is a pointer variable.

88
06:18.070 --> 06:22.030
This is initialization, address of a variable is given to p.

89
06:22.040 --> 06:30.640
Now, I want to access this 10, So I want to print, so I can say printf ("%d", a) ;

90
06:30.970 --> 06:32.830
So, this will print the value. Then,

91
06:33.100 --> 06:35.970
I want to access same thing by using pointer.

92
06:36.040 --> 06:37.840
So, from pointer I want to access it.

93
06:37.900 --> 06:47.520
So again, I will say  printf ("%d",  and if I say p, it will be taking 200, but no I want this

94
06:47.530 --> 06:48.030
data.

95
06:48.250 --> 06:52.140
So say *p.

96
06:52.880 --> 06:58.900
So, this is declaration, and this is assignment or initialization,

97
06:58.930 --> 07:05.470
That is, it is initialized with some value, and this is dereferencing, this portion is dereferencing.

98
07:05.470 --> 07:11.330
So when you are dereferencing, you have to use *, and declaring you have to use a * and initialization

99
07:11.350 --> 07:14.020
directly we can write p.

100
07:14.050 --> 07:18.350
So you have to get familiar with the syntax, declaration, initialization, dereferencing.

101
07:18.790 --> 07:22.840
So this how I have already taken a data variable and making a pointer point on it.

102
07:22.840 --> 07:29.650
In this example I'm not using pointer to access the heap memory, but next I will show you how to access

103
07:29.830 --> 07:31.720
heap memory using a pointer.

104
07:31.740 --> 07:35.770
I will declare a pointer variable. First of all, this is a pointer variable.

105
07:36.970 --> 07:44.170
So this, whenever you declare something, that definitely takes place in stack; stack frame of that particular

106
07:44.170 --> 07:46.680
function. So, p is created here,

107
07:47.990 --> 07:48.460
Right.

108
07:48.520 --> 07:54.160
Whenever you declare it will be inside stack. Remember, every variable declared, when you declare the variable

109
07:54.220 --> 07:55.900
it will be inside stack.

110
07:55.900 --> 07:58.860
Now I want to allocate memory in heap.

111
07:58.870 --> 08:02.390
So I want to create an array of size of 5 in the heap.

112
08:02.380 --> 08:04.580
So, how to get memory in heap?

113
08:05.230 --> 08:08.200
In C language the function name is malloc ( ).

114
08:08.320 --> 08:11.430
When you write malloc ( ), then only you get the memory in heap.

115
08:11.710 --> 08:16.180
So here I will write down, malloc ( ) .

116
08:16.300 --> 08:24.820
So for this I have to include some library, that is, #include < stdlib.h > , right.

117
08:24.820 --> 08:29.010
Now I can use this function malloc ( )

118
08:29.020 --> 08:32.990
Now here, I should mention the size, so malloc ( ) 

119
08:33.010 --> 08:35.620
take the size, how much memory you want.

120
08:35.620 --> 08:38.080
So you have to mention in terms of bytes.

121
08:38.140 --> 08:41.590
So I want 5 integer so, 5.

122
08:41.590 --> 08:45.470
Then what is the size of the integer we are assuming it as 2 bytes.

123
08:45.490 --> 08:48.260
So let the compiler decide it.

124
08:48.420 --> 08:54.160
see, we are assuming it, but it may be taking 4 bytes, or 2 bytes, so let the compiler decide the size,

125
08:54.490 --> 08:59.840
so we can use the operator, called the sizeof operator and to that

126
08:59.840 --> 09:07.090
operator, I will pass int, so it will give the size of an integer, size of integer, if it is 2 bytes then

127
09:07.080 --> 09:14.590
2*5, total 10 bytes of memory this malloc ( ) function will allocate. So, it will allocate total 5 integers,

128
09:15.700 --> 09:24.030
right. Now, that memory is allocated. Suppose the starting address of this is 5000, for example,

129
09:25.170 --> 09:33.240
First byte address is 5000, and so on. Then, that should be pointed by a pointer because we cannot access

130
09:33.240 --> 09:35.530
it unless we have a pointer.

131
09:35.760 --> 09:38.990
So I will assign this to a pointer.

132
09:39.120 --> 09:42.410
Now this malloc ( ) function returns void pointer.

133
09:42.420 --> 09:46.270
So we have to type-caste it and say it is integer pointer.

134
09:46.380 --> 09:49.410
Now this line will allocate heap memory.

135
09:49.440 --> 09:53.760
Remember, whenever you say malloc then only it will allocate in heap.

136
09:53.760 --> 09:56.060
So this p, will be pointing on this one.

137
09:56.310 --> 09:58.360
So p will get the address 5000.

138
09:59.240 --> 10:01.490
So, it is just like something is there in heap,

139
10:01.680 --> 10:09.160
now, pointer is holding it, right. It is just holding one edge of that array that is 5000.

140
10:09.420 --> 10:12.530
Now using that pointer we can access the entire array.

141
10:13.110 --> 10:19.570
So this is how heap memory is created. And how to do the same thing in C++?

142
10:19.570 --> 10:26.980
So just we have to say  new. new is an operator in C++ of type Integer and say size, 5.

143
10:27.070 --> 10:29.120
So in C++ it is very simple.

144
10:29.140 --> 10:36.490
This is C++, and this C language. C language syntax is a little bit lengthy and C++ is very simple.

145
10:36.520 --> 10:38.510
So while explanation, I maybe writing new

146
10:38.520 --> 10:45.460
most of the time, right, on whiteboard; But actually in C language, I have to use malloc ( ) function for allocating

147
10:45.550 --> 10:46.600
memory in heap.

148
10:46.750 --> 10:51.100
So, this is how pointers are used for creating heap memory.

149
10:51.100 --> 10:56.560
So this was the introduction of a pointer. In the coming videos, we will see how to have a pointer upon

150
10:56.560 --> 10:59.920
an array and how to have a pointer upon a structure.

151
10:59.920 --> 11:01.450
We'll learn about all these things.