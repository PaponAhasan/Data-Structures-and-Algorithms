WEBVTT

0
00:00.510 --> 00:04.430
In this video, we will learn about Structure as a Parameter.

1
00:05.610 --> 00:11.580
If you are sending a Structure as Parameter to some function, it may be Call by Value or Call by

2
00:11.990 --> 00:15.560
Address, Call by Reference is there in C++.

3
00:15.570 --> 00:17.750
So I will show you Call by Reference also.

4
00:18.000 --> 00:21.750
So first, let us look at Call by Value method.

5
00:21.750 --> 00:26.760
See, for that already I have an example this is a structure rectangle having length and breadth as members.

6
00:26.760 --> 00:32.610
Then I have a main function having a variable of type rectangle and it initialized with it 10 and 5,

7
00:32.610 --> 00:36.330
so a variable is created with values 10 and 5.

8
00:36.370 --> 00:43.890
Now I want a function to calculate the area of rectangle by multiplying length and breadth. So I want to write a function

9
00:43.940 --> 00:49.050
called area, so this function, the selection is already here.

10
00:49.170 --> 00:50.870
Now what I should pass from here?

11
00:50.920 --> 00:52.450
Shall I pass length separate, 

12
00:52.480 --> 00:53.390
breadth separate?

13
00:53.400 --> 00:56.900
No need, You can send the structure itself.

14
00:57.060 --> 00:59.430
Yes, that is the benefit of structure.

15
00:59.430 --> 01:02.990
You can send the structure itself, and the structure is carrying length and breadth.

16
01:03.450 --> 01:05.000
So both will be passed as one

17
01:05.040 --> 01:05.680
Parameter.

18
01:05.790 --> 01:09.770
So it will be passed as a single variable, single data member.

19
01:10.020 --> 01:11.370
So write r here.

20
01:11.610 --> 01:13.800
So structure is passed as parameter.

21
01:13.940 --> 01:16.260
Now what should be the parameter type of this function?

22
01:16.260 --> 01:21.050
So the argument type should be struct rectangle r

23
01:21.640 --> 01:22.290
.

24
01:22.830 --> 01:24.340
So it's rectangle r

25
01:24.540 --> 01:25.120
.

26
01:25.230 --> 01:26.650
This is Call by Value.

27
01:26.690 --> 01:33.720
So instead of r, I will say, r1, just a change of name so you should not feel that they are same,

28
01:34.110 --> 01:36.190
this variable is different, that variable is different.

29
01:36.300 --> 01:42.600
So I have taken parameter as r1. Now, that is Call by Value because here I did not write any

30
01:42.600 --> 01:45.020
* or I did not write &.

31
01:45.030 --> 01:53.200
This is Call by Value. So, in Call by Value what happens? This object or this variable is passed by value,

32
01:53.410 --> 01:59.650
So a new variable will be created here, a new variable r1, and it will have its own member that is

33
01:59.650 --> 02:02.820
length and breadth, right.

34
02:03.010 --> 02:05.510
So the values will be copied here.

35
02:06.160 --> 02:08.390
So it means separate object will be created.

36
02:08.410 --> 02:13.600
Yes, separate object will be created in Call by Value and everything will be copied in the corresponding

37
02:13.600 --> 02:15.440
members.

38
02:15.470 --> 02:17.160
This is the benefit of structure.

39
02:17.190 --> 02:22.060
This is one more thing, one more useful feature. Now, here, what I want to do?

40
02:22.070 --> 02:23.990
Just calculate area.

41
02:24.050 --> 02:29.690
So I have to multiply length and breadth. So, directly I will write down, return, I will directly write down in the return

42
02:29.690 --> 02:32.150
statement r1 . length

43
02:32.330 --> 02:42.890
So r1's length, right? into r1 . breadth that's all. It will return the result and this printf

44
02:42.890 --> 02:48.200
will print it. This is Call by Value.

45
02:48.530 --> 02:56.530
Now one thing, inside this one if I make any changes, if I say
r1 . length ++ , if I modify

46
02:56.530 --> 02:59.530
length, before returning, so this becomes 11.

47
02:59.620 --> 03:00.900
So will it change this one?

48
03:01.060 --> 03:02.880
No it will not change that one.

49
03:02.950 --> 03:04.090
It is Call by Value.

50
03:04.180 --> 03:09.320
So the actual parameter will not be modified. This is actual parameter, and this is a formal parameter.

51
03:09.370 --> 03:12.750
If you're making changes to formal, it will not affect actual.

52
03:12.790 --> 03:13.750
Right?

53
03:14.050 --> 03:15.350
This is one thing.

54
03:15.640 --> 03:15.890
Now,

55
03:15.920 --> 03:21.460
Next I will show you Call by Reference.

56
03:21.550 --> 03:24.810
So, for Call by Reference, I don't have to do anything much.

57
03:24.850 --> 03:33.560
It will be same thing only, and only the thing I have to do here is I should write & r1. Now, that's a 

58
03:33.560 --> 03:34.330
reference.

59
03:34.420 --> 03:39.520
So a new object will not be created but the same thing is called as r1 also.

60
03:40.420 --> 03:43.300
Yes we have already learned about the references.

61
03:43.420 --> 03:48.220
So the same thing is called as r1 and you know very well that this will not be a separate block

62
03:48.250 --> 03:52.360
of machine code, it will be pasted at the place of function call.

63
03:52.360 --> 03:54.490
We have already learned about this.

64
03:54.490 --> 04:02.560
Only that I have to write & and, rest of the things remain same only, then if I say r1 . length ++

65
04:02.560 --> 04:03.600
r1 . length ++

66
04:03.610 --> 04:05.160
Yes this is modified.

67
04:05.170 --> 04:10.640
This will become 11 that same thing gets modified, right.

68
04:10.640 --> 04:15.850
So, though for calculating area, I don't need to Call a reference, for calculating area I need to Call

69
04:15.860 --> 04:19.160
by Value, because it is just supposed to read the values.

70
04:19.370 --> 04:24.360
So you should know very well, that which function should use which method for.

71
04:24.380 --> 04:26.930
parameter passing, right.

72
04:26.960 --> 04:30.620
So this needs Call by Value but also I have explained you by Call by Reference.

73
04:30.620 --> 04:31.760
How to do that.

74
04:31.880 --> 04:33.890
In that reference, I can use dot operator.

75
04:34.040 --> 04:34.420
Yes.

76
04:34.420 --> 04:34.970
dot operator

77
04:35.000 --> 04:38.670
Simple as a normal object or normal variable.

78
04:39.140 --> 04:41.600
Now next, I will show you Call by Address.

79
04:41.600 --> 04:44.630
So for that I will change the function.

80
04:44.870 --> 04:49.810
I will write down another function for Call by Address.

81
04:49.950 --> 04:56.240
Now, for Call by Address, I have an example, I'm calling the function name as change length. Then suppose, I want to

82
04:56.240 --> 04:58.340
change this length, right.

83
04:58.460 --> 05:01.340
I want to make it 15, so I can make changes here also

84
05:01.340 --> 05:03.530
I can make changes also.

85
05:03.620 --> 05:09.110
No I want it to be done by a function, I don't want to do anything inside main ( ) function, right.

86
05:09.120 --> 05:14.600
Main function, we should imagine it like a manager and he's having all his assistants and he didn't want

87
05:14.600 --> 05:16.520
to do anything by himself.

88
05:16.520 --> 05:19.340
He just want to assign the job to all his assistant.

89
05:19.460 --> 05:23.060
He knows how to do the work what the work should be done.

90
05:23.060 --> 05:26.640
So every work he would assign to assistants, so we should imagine it like this.

91
05:26.690 --> 05:31.500
So main function can change but main function is not doing it, assistant will do it.

92
05:31.670 --> 05:33.320
So that is change length function.

93
05:33.330 --> 05:36.590
So we want this function to change this length.

94
05:36.740 --> 05:41.720
So if you want some function to modify actual parameter then it must be called by the method

95
05:41.730 --> 05:42.220
Call by Reference.

96
05:42.230 --> 05:44.230
So we are learning Call by Address

97
05:44.240 --> 05:46.260
Let us write Call by Address.

98
05:46.430 --> 05:49.130
First of all, from here I should go on that function.

99
05:49.130 --> 05:53.060
So yes I should call that function change length, right.

100
05:53.240 --> 05:57.540
Then what is the parameter I should pass? rectangle,

101
05:57.690 --> 05:58.210
by Address.

102
05:58.220 --> 06:01.980
So I should pass &, address, so here what it should take?

103
06:02.030 --> 06:08.370
It should take it as a pointer, so struct rectangle pointer, right.

104
06:08.460 --> 06:11.880
* p , then along with this

105
06:11.960 --> 06:14.100
also, I should pass the new length.

106
06:14.150 --> 06:19.820
So let us say want to make it as 20, instead of 15 let us say 20 then it should also take new

107
06:19.820 --> 06:24.530
length, so it is integer l, so it is taking by pointer.

108
06:24.620 --> 06:30.320
So when you call this function how it looks like, this p is a pointer that belongs to this function and

109
06:30.320 --> 06:32.860
this is pointing on this one.

110
06:33.200 --> 06:36.070
Now we have already learned pointer to a structure.

111
06:36.400 --> 06:41.530
So now you can see that pointer to a structure is useful in  parameter passing also. I want to modify

112
06:41.530 --> 06:44.280
that length, so say, p ->

113
06:44.350 --> 06:51.460
Because for accessing this member indirectly using pointer we have to use ->, p -> length = l ;

114
06:51.820 --> 06:57.720
So this length would be modified to 20. That's it.

115
06:58.050 --> 06:58.830
So this is how

116
06:59.400 --> 07:02.750
We can use Call by Address for the structure.

117
07:03.120 --> 07:06.540
So this type of thing I have used in my course.

118
07:06.570 --> 07:12.420
So whenever I'm writing structure and function so wherever I have to make changes in a structure

119
07:12.720 --> 07:17.060
I'm using Call by Address, because I'm writing C language code, right.

120
07:17.070 --> 07:21.970
So basic code I'm writing in C language only, so I have used Call by Address.

121
07:21.980 --> 07:27.270
So from here I'm sending an address and then I'm using a pointer and by using arrow, I accessing the

122
07:27.270 --> 07:28.200
members.

123
07:28.230 --> 07:32.730
So you should be familiar with this code and if you are comfortable with this one then you can smoothly

124
07:32.730 --> 07:35.300
follow the rest of the topics.

125
07:35.560 --> 07:36.310
Right.

126
07:36.390 --> 07:39.950
So this is the method for Call by Address.

127
07:40.000 --> 07:41.840
Now one more thing I have to show you.

128
07:41.940 --> 07:45.900
I'll remove this and they'll explain you.

129
07:45.920 --> 07:47.590
One more thing that I have to show you.

130
07:48.170 --> 07:52.130
I have defined a structure here having array as a data member.

131
07:52.460 --> 07:57.560
And one more integer data member, 2 data members I have taken. Mainly array is important there. So,

132
07:57.760 --> 08:04.580
we'll focus on array. Here, inside the main function I have created a variable of that type struct test

133
08:05.120 --> 08:10.270
and the name is t, and I have also initialized it so it will have two members, array and n.

134
08:10.350 --> 08:15.740
So array, the size of the array is 5 and one more integer variable is there.

135
08:15.770 --> 08:20.200
So all are initialized. Now, can we send

136
08:20.420 --> 08:24.140
structure as a parameter in Call by Value?

137
08:24.390 --> 08:24.780
Yes.

138
08:24.790 --> 08:28.430
Call by Value, we can send. But can we send an array with Call by Value?

139
08:28.550 --> 08:34.850
No, array can be sent only by Call by Address, already we have discussed this in previous video, then

140
08:35.510 --> 08:37.730
but this is structure having an array.

141
08:37.790 --> 08:39.270
Can you pass this by value?

142
08:39.650 --> 08:40.190
Yes.

143
08:40.200 --> 08:44.580
Structure you can pass by value even if it is having an array inside.

144
08:44.600 --> 08:47.140
So that's the important thing we are learning now.

145
08:47.150 --> 08:51.950
So here I have a function called fun and I'm taking it as a Call by Value.

146
08:51.950 --> 08:55.840
So from here on passing t, so whether it works? yes it works.

147
08:55.850 --> 08:58.280
So what happens when this is passed?

148
08:58.610 --> 09:02.290
So again a new t1 is created with an array.

149
09:02.690 --> 09:03.480
Right.

150
09:03.500 --> 09:08.070
And also n, and every thing from here, it will be copied here.

151
09:08.090 --> 09:09.830
2, 4, 6, 8, 10.

152
09:09.980 --> 09:17.820
And also value 5, everything will be copied. So,when a structure is passed by value even if it is having an array

153
09:17.940 --> 09:21.800
an array will be created separately in the member and it will be filled.

154
09:22.100 --> 09:26.730
So imagine all these values has to be copied automatically just done by the compiler.

155
09:26.990 --> 09:28.470
So this is time consuming.

156
09:28.640 --> 09:33.880
That is the reason the compiler doesn't support array by value, they allow only Call by Reference. But difference is

157
09:33.890 --> 09:37.220
inside the structure they support it. They have to do it.

158
09:37.580 --> 09:43.710
So this will be copied. We are not copying it. Internally it is happening means compiler will do this.

159
09:43.710 --> 09:44.420
.

160
09:44.510 --> 09:50.720
So yes now if I make any changes, how I can access this one? I can say  t1 . A, because it's own member,

161
09:50.720 --> 09:50.980
Right?

162
09:50.990 --> 09:52.080
It's Call by Value.

163
09:52.180 --> 09:55.800
And I can say, t1 . A[0] = 10;

164
09:55.910 --> 09:58.610
So this will become 10, right.

165
09:58.970 --> 10:04.330
So I can change the value, t1 . A[1] = 9;

166
10:04.430 --> 10:07.000
So this will become 9.

167
10:07.970 --> 10:10.460
But this will not change, because this is Call by Value.

168
10:11.900 --> 10:15.590
So I can use dot operator and access the members.

169
10:15.590 --> 10:19.630
So that's all, We have seen how we can pass structure as parameter.

170
10:19.760 --> 10:23.810
We have seen Call by Value, We have seen Called by Reference, We have seen Call by Address, and also

171
10:23.810 --> 10:29.290
we have seen that, even if an array is there inside a structure, that can be passed by value. Structure can

172
10:29.290 --> 10:30.080
be Passed by Value.

173
10:31.440 --> 10:32.630
That's all in this video.