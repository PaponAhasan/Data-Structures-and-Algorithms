WEBVTT

00:00.390 --> 00:04.110
Let us talk about the time and space complexity.

00:04.120 --> 00:08.760
This is a very important topic and sometimes it is difficult for the students to understand though it

00:08.760 --> 00:11.370
is not that difficult if not complex.

00:11.370 --> 00:15.840
Though the word complexity is used is very simple.

00:15.840 --> 00:17.090
Let me explain you.

00:17.190 --> 00:19.150
What does it mean by bank on Lake City.

00:19.170 --> 00:22.530
Then afterwards I'll tell you about space complexity also.

00:22.530 --> 00:26.750
So first let us start with 10 complexity see in daily life.

00:26.760 --> 00:32.640
When we do any work any task we want to know how much time it takes for that performing that particular

00:32.640 --> 00:37.410
task let us suppose it is a one hour task or a one day task.

00:37.460 --> 00:41.540
So that amount of time required depending on the work that we have to do.

00:42.260 --> 00:47.990
So usually in daily life we measure the time based on the work that we have to do.

00:48.560 --> 00:54.010
So now we're using machines to do over work that is computers to do over work.

00:54.080 --> 00:57.950
So you want to know how much time and machine takes for doing the same task.

00:58.280 --> 01:05.090
Like if a person is making a bread in 15 minutes 20 minutes then if you're using machine for making

01:05.090 --> 01:07.240
that bread how much time the machine takes.

01:07.240 --> 01:11.980
We are interested in that what if machine is taking 45 hours then it's better to do it manually.

01:12.710 --> 01:15.870
So how much time a machine takes is very important for us.

01:15.920 --> 01:18.020
So we use computers for problem solving.

01:18.050 --> 01:22.710
What type of problem solving the work that we use do it using pen and paper.

01:22.760 --> 01:23.520
That same work.

01:23.540 --> 01:25.230
We want our computers to do that.

01:25.520 --> 01:30.800
So computers are used for performing computation task so computation also needs time.

01:31.370 --> 01:35.270
So you want to measure how much time a machine will take.

01:35.270 --> 01:40.640
So actually that depends on the process or the procedure for completing that task.

01:40.970 --> 01:46.160
So that time complexity basically depends on the procedure that you are adopting so far giving you the

01:46.160 --> 01:49.970
idea I have taken various examples using these examples.

01:49.970 --> 01:55.040
I'll explain you what procedure may take what amount of time.

01:55.220 --> 02:01.150
So let us start with three feet this scenario of some size and some elements are there.

02:01.160 --> 02:02.710
So how many elements are there.

02:02.720 --> 02:05.540
See this is the example already I have taken.

02:05.540 --> 02:11.810
And you can count that there are total 10 elements but validity always 10 elements are depends on the

02:11.810 --> 02:12.300
problem.

02:12.650 --> 02:13.760
So depending on the problem.

02:13.820 --> 02:15.110
So how many elements may be there.

02:15.110 --> 02:20.720
The list of elements in an array we say n elements we don't know how many elements we have today maybe

02:20.720 --> 02:24.200
ten or ten thousand or ten million.

02:24.260 --> 02:25.170
We don't know.

02:25.190 --> 02:32.920
So we say n n means some number of elements that number of elements may start from one up to infinity.

02:32.990 --> 02:37.430
So we don't define infinity for the maximum number or whatever that number you can imagine you take

02:37.430 --> 02:44.150
that one for any means not just five or 10 does the first important thing mostly store and get confused

02:44.150 --> 02:44.460
here.

02:44.960 --> 02:47.230
So elements some number of elements.

02:47.270 --> 02:51.600
So let us say there are any elements in this list.

02:51.760 --> 02:54.300
Now what do you want to do with these elements.

02:54.300 --> 02:56.120
I want to add all of them.

02:56.340 --> 03:01.560
So you have to go through all of them if one by one you have to take their limit and go on adding it

03:02.290 --> 03:05.220
for how much time it takes depends on the number of elements.

03:05.220 --> 03:10.940
So what is the time taken and we say n the next thing what we want to do.

03:11.030 --> 03:15.680
I want to search for a particular number whether element twelve is there or not search for it.

03:15.800 --> 03:16.580
Yes it is there.

03:17.120 --> 03:18.970
I want to search for element 21.

03:18.980 --> 03:21.080
Is it there or not check for all.

03:21.080 --> 03:22.730
Not really one is not there.

03:22.970 --> 03:25.510
So I can most how much time it is taking.

03:25.610 --> 03:28.750
It depends on the number of elements that you have to compare.

03:28.820 --> 03:31.130
So how many elements are there and elements are there.

03:31.190 --> 03:32.430
So what is the time taken.

03:32.840 --> 03:40.440
And so the famous n so it means in a list if you have some n elements and you are going through all

03:40.440 --> 03:43.610
of them just once then the timers end.

03:44.370 --> 03:53.670
So this and the v represented as a degree degree so we can say order off and we usually use the term

03:53.790 --> 03:56.060
order degree or order or something.

03:56.130 --> 04:04.740
So we use the term order of and there are other times like a big deal or may God TTR that I will explain

04:04.740 --> 04:09.990
you at the end of the course because till then you will be having the good understanding of time complex

04:09.990 --> 04:16.320
it is then I can explain you what is B go on a go and take on so told the course I'll be using term

04:16.770 --> 04:18.360
order off.

04:18.510 --> 04:22.470
So when we know what are is important notations like before me that take out then you will understand

04:22.500 --> 04:28.520
how to use them so let's say order of and then next thing.

04:28.520 --> 04:33.350
Next very important thing if you want to access that all the elements then what the code that you have

04:33.350 --> 04:36.820
to write for are you assigned zero.

04:36.860 --> 04:43.820
I use less than an I plus plus then whatever you want to do here makes you want to add all of them are

04:43.880 --> 04:50.780
so something or count number of elements are finding maximum element whatever you want to do that logic

04:50.780 --> 04:51.570
come here.

04:51.590 --> 04:53.870
So that procedure comes here.

04:53.870 --> 05:00.690
So whatever the procedure may be then this for loop for taking us through all those elements 1 So how

05:00.700 --> 05:01.850
many elements an element.

05:01.850 --> 05:09.940
So what is the time and knowledge listen the very important thing for finding the time complexity either

05:09.940 --> 05:16.240
you can measure the time based on the work that you are doing for the of the procedure if you're clear

05:16.240 --> 05:22.930
with your procedure you can know the time or else from the chord program code also you can find the

05:22.930 --> 05:29.950
time complexity if there is a follow up going through 0 2 lastly amendments it's Edna taking or different

05:29.950 --> 05:38.110
time whatever it is there inside will repeat four and times so we analyse based on the procedure also

05:38.440 --> 05:45.100
based on the core dollars so and the most confusing thing is when the code is given we get confused

05:45.220 --> 05:48.480
how to analyze this one so actually what the chord is doing.

05:48.520 --> 05:54.730
You do that work and based on the work you analyse it it's very simple it's very simple if you don't

05:54.730 --> 06:01.320
want to understand what the chord is doing then is difficult task a follow up is used means there is

06:01.320 --> 06:06.300
a chance that times are off and now let us move to the next situation.

06:06.400 --> 06:10.920
See and this list is always being on the first element.

06:10.920 --> 06:18.240
I am competing or processing all other elements once then being on the second element.

06:18.240 --> 06:20.870
Again I am processing all other elements.

06:20.880 --> 06:24.360
Maybe I'm competing for sorting purposes whatever the purpose may be.

06:24.480 --> 06:30.350
This five am competing or processing with the rest of all the elements like that for each element.

06:30.420 --> 06:33.280
I'll be checking with all the rest of the elements.

06:33.450 --> 06:38.300
So for one value it will take for all means and elements.

06:38.490 --> 06:39.750
Then for the next value also.

06:39.750 --> 06:47.240
If it is chicken for all processing for all the net n n elements so n elements are being processed but

06:47.690 --> 06:52.910
how many times for each element and elements how process so this will be in squared.

06:52.910 --> 06:56.750
This is an illusion that is in square so we can sell it rough and squared

06:59.490 --> 07:02.300
so does another case lie in the same case.

07:02.340 --> 07:08.550
I'll show you one more thing for processing like this how the court should look like the court should

07:08.550 --> 07:10.060
have nested for loop.

07:10.150 --> 07:17.100
Again I should have for loop that is for GSI in zero G is less than N and joblessness and inside this

07:17.180 --> 07:20.950
Albert I think that processing whatever the work I want to do.

07:21.000 --> 07:22.050
These will be the statements.

07:22.410 --> 07:29.190
So when you have two nested for loops a 10 square simple you don't have to check a line by line every

07:29.190 --> 07:34.830
statement at all just from the code you go got the rough idea you can say it's in square but sometime

07:34.870 --> 07:37.340
for analyzing the code we check every line.

07:37.620 --> 07:39.920
So the idea is we should not miss any line.

07:39.930 --> 07:40.590
We should create it.

07:40.590 --> 07:41.970
Check check it thoroughly.

07:41.970 --> 07:48.810
That's why we write the time complexity but all the time complexity is written in terms of the degree

07:48.810 --> 07:53.490
of a polynomial so it is sort of an squared nested for loop mints and squared.

07:53.730 --> 07:55.670
So let us follow it like a formula.

07:56.890 --> 08:00.100
Port situation for the same Ari c.

08:00.250 --> 08:04.720
Suppose being on first element and processing the rest of the elements.

08:06.660 --> 08:12.990
For N minus one element sound processing then being on the second element and processing the rest of

08:12.990 --> 08:15.300
the element I'm not processing up on this one right.

08:15.810 --> 08:22.500
So and minus two then being on the third element time processing let's drop them.

08:22.500 --> 08:23.920
It depends what you are doing.

08:23.940 --> 08:24.230
Right.

08:24.480 --> 08:29.880
So imagine something you are doing so you're processing the star of the elements so this is minus three

08:30.180 --> 08:30.690
like that.

08:30.990 --> 08:37.610
It will be go under the using then finally it will be for elementary element good element then 1.

08:37.680 --> 08:38.700
This is what.

08:38.900 --> 08:43.640
And in goo and the minus one might do some off us and natural number.

08:43.650 --> 08:45.330
So it is not and minus 1.

08:45.960 --> 08:50.030
So this will be and squared minus end by 2.

08:50.040 --> 08:52.210
So what is the degree of this polynomial.

08:52.260 --> 08:53.220
This is N squared.

08:53.580 --> 08:59.830
So it's order off in squared so that's what the time complexity that we are writing.

08:59.940 --> 09:02.140
We are writing the degree of a polynomial.

09:02.160 --> 09:10.100
See this time I have done detailed analysis and I got a polynomial and for that I got a function that's

09:10.110 --> 09:15.180
like a function and a degree of a functions and square four times and square.

09:15.180 --> 09:21.230
If same thing I did in the form func form of a for loop then this is Jason not starting from zero where

09:21.240 --> 09:26.660
G will be starting from I plus 1 she not again doing this set for loop.

09:26.760 --> 09:29.030
So Atmore so this will take and squared time.

09:29.390 --> 09:34.150
Yes the next I'll show you one more situation.

09:34.160 --> 09:35.250
4 to 1.

09:35.260 --> 09:36.180
Let us look at this.

09:36.220 --> 09:38.540
I'll remove this one now in disarray.

09:38.540 --> 09:42.360
Suppose first of all you're processing the middle element suppose Ford is the middle element right there

09:42.370 --> 09:43.780
are 10 elements.

09:43.780 --> 09:46.120
So fifth element of the seminal element.

09:46.330 --> 09:49.690
Len Nix either on the left side or on the right side.

09:49.760 --> 09:54.190
Again you go in the middle Suppose suppose there's no middle element on the side living in the middle

09:54.190 --> 09:55.060
element on this side.

09:55.360 --> 09:58.630
So in this way we are not processing the entire list.

09:58.630 --> 10:00.690
We are processing half of the list.

10:00.700 --> 10:01.900
Then again it's half.

10:02.050 --> 10:03.100
Then again it's half.

10:03.100 --> 10:06.420
So that process is always dividing the list by two.

10:06.430 --> 10:13.870
So when something is successful successively divided until it reaches one that is represented as long.

10:15.160 --> 10:17.140
And we are divided by 2 1/2.

10:17.230 --> 10:26.350
So log off n elements log n so the time complexities log in if we are not processing all elements.

10:26.350 --> 10:32.140
Then if a later go to for that one then the quarter will look like this for i.e. start from

10:35.000 --> 10:40.440
and an eye is greater than one eye is getting divided by two every time

10:44.720 --> 10:46.990
not just by looking at for loop.

10:47.000 --> 10:48.140
Don't tell.

10:48.140 --> 10:51.970
Blindly order often because just not previously we saw it often.

10:52.150 --> 10:52.700
I read it.

10:52.700 --> 10:55.280
How the follow up is behaving.

10:55.280 --> 10:58.990
That's why we check it thoroughly when we are reading the code.

10:59.060 --> 10:59.950
We totally check.

10:59.950 --> 11:03.350
Line by line so that we should not go wrong.

11:04.250 --> 11:07.120
But overall we need answer log in.

11:07.160 --> 11:16.530
If the value of Gounder I is getting divided by two every time then it is log n divided by two log in

11:16.530 --> 11:18.890
base to and how long it is happening.

11:18.890 --> 11:20.390
I can agree just one.

11:20.510 --> 11:24.990
The same thing can even be done using Y loop C I assign n.

11:25.430 --> 11:34.430
And while I is greater than 1 and some processing I is always divided by 2.

11:34.450 --> 11:36.670
Same thing in store for loop.

11:36.680 --> 11:44.760
You can use a while loop also usually when this is not incrementing one by one every time for loop is

11:44.760 --> 11:46.970
not incrementing by one every time.

11:46.980 --> 11:53.460
We prefer using VI loop but in C C++ Java programming when for loops are there people use for low for

11:53.460 --> 11:57.580
this purpose also followup is used for counters which are implementing by 1.

11:57.900 --> 12:02.820
So anyway when this is written you have to read it thoroughly and find out how much time it is taking.

12:02.820 --> 12:09.960
So we have seen 4 different behaviors offer procedures that are performed on tree and also have shown

12:09.960 --> 12:16.360
you the code and also shown you how we can analyze the from the code how we get analyzed from the work.

12:16.440 --> 12:20.660
So if you were analyzing from the work the process that's what we got.

12:21.420 --> 12:23.270
Now let us proceed ahead.

12:23.310 --> 12:27.690
See this is the linguist we'll be studying about this linguistic data structure later on this will be

12:27.690 --> 12:32.670
same as early like this is list and this also a list.

12:32.790 --> 12:33.990
So what already started there.

12:33.990 --> 12:36.090
Same thing applies here.

12:36.090 --> 12:42.470
The next is a max matrix as having how many elements the dimensions are formed by 4.

12:42.860 --> 12:50.510
So total how many elements if dimension is in throws and then total in squared elements so when you're

12:50.510 --> 12:55.730
processing up on a matrix then it will require N squared amount of time.

12:55.730 --> 13:02.450
If you're processing all the elements if you say no I'm just processing a roll then Roy's having an

13:02.450 --> 13:05.570
elements order often 9 processing just a column.

13:05.570 --> 13:13.270
So again it's an order of and if you're processing all elements then it is and squared null should the

13:13.270 --> 13:14.400
code for that.

13:14.590 --> 13:23.350
I remove this for processing and mappings of elements we need to nested for loops ie plus plus and inside

13:23.350 --> 13:31.150
this for Geoscience 0 JS less than N and Jebus plus whatever you want to do with those elements you

13:31.150 --> 13:32.510
can do that.

13:32.530 --> 13:38.980
So this is and square not for one element if you're processing more up on that element and that requires

13:38.980 --> 13:45.540
suppose a loop are suppose you are calling a function which is having a loop then the time will be more

13:45.550 --> 13:50.670
fa fa fa 3 follows inside then it will be n cube right.

13:51.010 --> 13:53.480
If you are processing only one unit of time.

13:53.490 --> 14:00.010
Just one statement or two statements are this simple statement no loops that sound square on then coming

14:00.040 --> 14:01.050
but this is structure.

14:02.040 --> 14:07.110
This looks like a really awful linguist like linguistic total how many elements are there.

14:07.140 --> 14:12.380
So here legacy and elements are there these elements so you can see that these are of different sizes.

14:12.510 --> 14:14.200
And here are the top five.

14:15.050 --> 14:17.430
So total how much processing is required.

14:17.790 --> 14:23.700
We have to process all these elements as well as using this early so we can see em plus and processing

14:23.700 --> 14:24.470
as required.

14:25.610 --> 14:29.550
If you say no I don't want to consider this I want to consider only the number of elements okay.

14:29.570 --> 14:33.600
Consider only in number of elements are driven.

14:34.340 --> 14:36.560
What does it mean by considering not considering.

14:36.710 --> 14:43.960
I'll give you an idea just listen as an example suppose you are giving a party to your friend from some

14:43.960 --> 14:48.370
45 friends you have call them on their hotel for a party then what is the cost.

14:48.410 --> 14:50.500
The cost of the food that you're taking there.

14:50.810 --> 14:58.280
Then the bill at the hotel plus travelling amount and if any Xstrata thinks that you are spending on

14:58.970 --> 15:00.190
tips you are giving.

15:00.260 --> 15:04.590
Do you consider that amount also and included as the cost for a party.

15:04.610 --> 15:10.650
It depends on you it depends on you the same way whether you want to analyze or not it depends on you.

15:10.650 --> 15:14.690
So you should be in a situation to understand whether you need it or not.

15:14.920 --> 15:15.200
Right.

15:15.200 --> 15:19.940
Mostly what students believe that they are doing it because it is a given other task as a challenge

15:20.810 --> 15:23.420
for somebody else a job they are doing.

15:23.420 --> 15:26.930
So they get worried that they should consider or not why I should leave it.

15:27.260 --> 15:29.020
So that is your choice.

15:29.030 --> 15:31.750
You'll be in that situation and solve it.

15:31.850 --> 15:32.510
So that's all.

15:32.900 --> 15:37.490
If you say I don't want to consider this means you are processing it but you don't want to consider

15:37.490 --> 15:42.030
the time taken for that one so only are often that's it.

15:42.040 --> 15:43.970
So this is structure is over.

15:44.170 --> 15:45.270
Now last one.

15:45.400 --> 15:47.830
This one does a binary tree.

15:47.830 --> 15:52.660
So if you have a 180 structure total elements are one two three four five six seven and seven elements

15:52.660 --> 15:53.330
are there.

15:53.470 --> 15:55.240
Then how much processing is done.

15:55.240 --> 16:00.220
Suppose you are processing searching or something and you are processing up on the elements only along

16:00.220 --> 16:04.210
the part like this one then this one on this one or this one then this one and this one.

16:04.210 --> 16:07.560
Suppose you're processing just along a part then then what is the height.

16:07.560 --> 16:08.380
It depends on the height.

16:08.380 --> 16:10.070
So how many elements you are processing.

16:10.120 --> 16:13.990
See there are some elements divided by two then divided by two.

16:14.020 --> 16:19.960
Until it reaches one element so total seven elements either as from the bottom if you see the number

16:19.960 --> 16:22.330
of elements are divided by good and divided by two.

16:22.330 --> 16:25.700
So it looks like log in this log in Bristol.

16:25.960 --> 16:27.790
So we'll be studying about this one.

16:27.850 --> 16:33.880
So if you're spending time up on our tree along the height of our tree then it is log in.

16:34.210 --> 16:38.590
Next situation if you say no I want to process all the elements then how many elements are there any

16:38.600 --> 16:39.010
element.

16:39.010 --> 16:46.480
So it is all rough and then whatever the program code that you write for processing this one and back

16:46.500 --> 16:48.200
code also will be ordered off.

16:48.280 --> 16:51.310
And only if you analyze that one.

16:51.310 --> 16:55.670
So this is the general idea I have given you a border time complexity for the time complex it is sole

16:55.670 --> 17:01.570
and solely dependent on the work that you are doing now a little bit on space complexity.

17:01.720 --> 17:06.900
We want to know how much space is consumed in main memory during the execution of a program.

17:07.600 --> 17:16.630
So Ari and elements are there thoughts are often this is an elements are there order often spaces and

17:16.930 --> 17:24.800
months and indeed years or any flaws or any doubles whatever it is and elements we say we are not concerned

17:24.800 --> 17:30.380
about the number of bytes number of bytes right we are not concerned more that we are not quite calculating

17:30.380 --> 17:38.300
that we want to know the space is dependent on what and the if the value of and is more the space will

17:38.310 --> 17:46.960
be more that's more ideas than here also send along with the element you need space for links also.

17:47.090 --> 17:55.330
So there is a two in two and again the degree is what order often then coming to this this is spaces

17:55.450 --> 18:04.930
and square and this is places M Plus and and the space here is and nodes are there sorts and are often

18:06.770 --> 18:10.560
so the next video I take few program call and show you.

18:10.590 --> 18:16.020
So without looking at the processing just from the program called How to find out the time complexity

18:16.020 --> 18:19.330
I will show you so that following the serial.
